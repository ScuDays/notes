---
title: 从热迁移启动到位图内存分配的完整过程
date: 2025-10-02 18:02:22
modify: 2025-10-02 18:02:22
author: days
category: ICSAS
published: 2025-10-02
draft: true
---
# 从热迁移启动到位图内存分配的完整过程
## 热迁移到位图分配的完整流程

### 1. 用户空间层（QEMU）

```bash
# 用户发起热迁移命令
virsh migrate --live vm1 qemu+ssh://target-host/system
```

```c
// QEMU内部处理
qemu_migrate_start()
    ↓
// 启用脏页日志
memory_region_set_dirty_log_mask(mr, LOG_VGA | LOG_DIRTY_PAGES)
    ↓
// 准备内存区域结构
struct kvm_userspace_memory_region region = {
    .slot = slot_id,
    .flags = KVM_MEM_LOG_DIRTY_PAGES,  // ← 关键标志！
    .guest_phys_addr = guest_addr,
    .memory_size = size,
    .userspace_addr = host_addr
};
    ↓
// 发起系统调用
ioctl(vm_fd, KVM_SET_USER_MEMORY_REGION, &region);
```

### 2. 系统调用接口

```c
// 内核接收 ioctl
sys_ioctl(fd, KVM_SET_USER_MEMORY_REGION, arg)
    ↓
// KVM 主入口
kvm_vm_ioctl(filp, ioctl, arg)  // virt/kvm/kvm_main.c:5158行
```

### 3. KVM 内核处理

```c
// virt/kvm/kvm_main.c:5158行
case KVM_SET_USER_MEMORY_REGION: {
    struct kvm_userspace_memory_region2 mem;
    
    // 从用户空间复制数据
    if (copy_from_user(&mem, argp, sizeof(mem)))
        goto out;
        
    r = kvm_vm_ioctl_set_memory_region(kvm, &mem);  // ← 5189行
    break;
}
```

###  4. 内存区域设置

```c
// virt/kvm/kvm_main.c:2138行
static int kvm_vm_ioctl_set_memory_region(struct kvm *kvm, 
                                         struct kvm_userspace_memory_region2 *mem)
{
    if ((u16)mem->slot >= KVM_USER_MEM_SLOTS)
        return -EINVAL;

    guard(mutex)(&kvm->slots_lock);
    return kvm_set_memory_region(kvm, mem);  // ← 调用核心函数
}
```

### 5. 内存区域核心处理

```c
// virt/kvm/kvm_main.c 中的 kvm_set_memory_region
static int kvm_set_memory_region(struct kvm *kvm, 
                                struct kvm_userspace_memory_region2 *mem)
{
    // 检查参数，创建新的内存槽结构
    struct kvm_memory_slot old, new;
    enum kvm_mr_change change;
    
    // 确定变更类型
    change = kvm_mr_change(old, new);
    
    // 🚀 关键步骤：准备内存区域（包括位图分配）
    r = kvm_prepare_memory_region(kvm, &old, &new, change);  // ← 1680行
    if (r)
        return r;
        
    // 提交变更
    kvm_commit_memory_region(kvm, &old, &new, change);
    return 0;
}
```

### 6. 位图分配准备

```c
// virt/kvm/kvm_main.c:1680行 - 我们添加了注释的函数
static int kvm_prepare_memory_region(struct kvm *kvm,
                                   const struct kvm_memory_slot *old,
                                   struct kvm_memory_slot *new,
                                   enum kvm_mr_change change)
{
    // 脏页位图的处理逻辑:
    if (change != KVM_MR_DELETE) {
        // 情况1: 新配置未启用脏页日志
        if (!(new->flags & KVM_MEM_LOG_DIRTY_PAGES))
            new->dirty_bitmap = NULL;
        // 情况2: 旧配置已有位图，直接复用
        else if (old && old->dirty_bitmap)
            new->dirty_bitmap = old->dirty_bitmap;
        // 情况3: 新启用脏页日志，需要分配新的位图 ← 热迁移走这个分支！
        else if (kvm_use_dirty_bitmap(kvm)) {
            // 🎯 关键：分配位图内存
            r = kvm_alloc_dirty_bitmap(new);  // ← 1709行
            if (r)
                return r;

            // 🚀 性能优化的核心！
            if (kvm_dirty_log_manual_protect_and_init_set(kvm))
                bitmap_set(new->dirty_bitmap, 0, new->npages);  // ← 1724行
        }
    }
    return 0;
}
```

### 7. 实际位图内存分配

```c
// virt/kvm/kvm_main.c:1434行
static int kvm_alloc_dirty_bitmap(struct kvm_memory_slot *memslot)
{
    // 计算单个位图大小
    unsigned long dirty_bytes = kvm_dirty_bitmap_bytes(memslot);
    
    // 🔥 实际内存分配（双倍大小用于双缓冲）
    memslot->dirty_bitmap = __vcalloc(2, dirty_bytes, GFP_KERNEL_ACCOUNT);
    if (!memslot->dirty_bitmap)
        return -ENOMEM;
        
    return 0;
}
```

### 8. 位图大小计算

```c
// include/linux/kvm_host.h:628行
static inline unsigned long kvm_dirty_bitmap_bytes(struct kvm_memory_slot *memslot)
{
    // npages: 内存槽的页面数量
    // BITS_PER_LONG: 64位系统通常是64
    // ALIGN: 向上对齐到64位边界
    // /8: 将位数转换为字节数
    return ALIGN(memslot->npages, BITS_PER_LONG) / 8;
}
```

### 9. 优化初始化（关键性能优化）

```c
// 如果启用了性能优化
if (kvm_dirty_log_manual_protect_and_init_set(kvm))
    bitmap_set(new->dirty_bitmap, 0, new->npages);
    
// bitmap_set 的作用：
// - 将位图的所有位设置为1
// - 假设所有页面都是脏的
// - 跳过后续的页面遍历和写保护操作
// - 性能从460ms优化到10ms！
```

## 完整时序图

```
用户命令    QEMU层        系统调用        KVM内核          位图分配
   |          |             |              |                |
   |→ migrate |             |              |                |
   |          |→ ioctl()    |              |                |
   |          |             |→ kvm_vm_ioctl|                |
   |          |             |              |→ set_memory   |
   |          |             |              |                |→ alloc_bitmap
   |          |             |              |                |→ __vcalloc(2×size)
   |          |             |              |                |→ bitmap_set(全1)
   |          |             |              |← 成功           |← 分配完成
   |          |             |← 成功         |                |
   |          |← 成功        |              |                |
   |← 迁移启动 |             |              |                |
```

## 关键节点总结

1. 触发点：`virsh migrate --live` 命令
2. 关键标志：`KVM_MEM_LOG_DIRTY_PAGES` 
3. 分配位置：`kvm_alloc_dirty_bitmap()` 函数
4. 优化点：`bitmap_set()` 全置 1 操作
5. 内存大小：`2 × ALIGN(npages, 64) ÷ 8` 字节

这就是从热迁移启动到脏页位图内存分配的完整过程！每个步骤都是自动进行的，用户只需要一个简单的迁移命令就能触发这整套复杂的内核机制。
