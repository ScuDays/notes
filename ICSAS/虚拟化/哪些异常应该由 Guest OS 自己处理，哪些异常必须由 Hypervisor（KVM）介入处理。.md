---
title: 哪些异常应该由 Guest OS 自己处理，哪些异常必须由 Hypervisor（KVM）介入处理。
date: 2025-09-10 22:11:26
modify: 2025-09-10 22:11:26
author: days
category: ICSAS
published: 2025-09-10
draft: false
---

- 哪些异常应该由 Guest OS 自己处理，哪些异常必须由 Hypervisor（KVM）介入处理。
并非所有 Guest OS 的异常都需要像之前描述的那样，由 KVM 来捕获和处理。

实际上，KVM 的设计哲学是最小化干预。绝大多数在 Guest OS 内部发生的常规异常，KVM 完全不会干涉，它们由 Guest OS 自己就消化了。只有那些会破坏虚拟化隔离性或需要 Hypervisor 提供特殊服务的异常，才会被 KVM 捕获。

我们可以将 Guest OS 的异常分为两大类：

---

### 第一类：Guest OS 内部处理的异常 (KVM 完全不介入)

这类异常的共同点是，Guest OS 拥有处理它们所需的全部信息和权限，且处理过程不会影响到 Host 或其他虚拟机。KVM 的目标就是在这里做到“隐身”，让 Guest OS 感觉自己运行在真实硬件上。

* 1. 系统调用 (System Calls)
    * 场景: Guest OS 里的一个应用程序（用户态）需要内核的服务（例如读文件），于是执行 `SVC` (Supervisor Call) 指令。
    * 处理: 这会触发一个从 Guest 用户态（EL 0）到 Guest 内核态（EL 1）的异常切换。这个过程完全在虚拟机的世界里发生。Guest OS 的内核会处理这个系统调用，完成后再返回 Guest 的用户程序。KVM 对此毫不知情，也没有理由介入。

* 2. 普通的页错误 (Normal Page Faults - Stage 1 Faults)
    * 场景: Guest OS 里的一个应用程序访问了一个已被换出到 Guest 虚拟磁盘（Swap 分区）的内存页面。
    * 处理: 这会导致阶段一（Stage 1）MMU 翻译失败，从而在 Guest 内部触发一个页错误异常。Guest OS 的页错误处理程序会被唤醒，它会从自己的虚拟磁盘中把页面数据读回来，更新自己的页表（Stage 1 页表），然后恢复应用程序的运行。这同样是 Guest OS 管理自己虚拟内存的常规操作，KVM 不参与。

* 3. 除零、非法指令等编程错误
    * 场景: Guest 里的一个程序执行了 `1 / 0`，或者一条 CPU 不认识的指令。
    * 处理: CPU 会触发一个异常，由 Guest OS 内核捕获。Guest 内核通常会向该程序发送一个信号（如 `SIGFPE` 或 `SIGILL`），将其终止。这纯属软件逻辑错误，与虚拟化无关。

---

### 第二类：必须由 KVM 捕获和处理的异常 (VM Exit)

这类异常的共同点是，如果让 Guest OS 直接处理，将会破坏安全性、稳定性，或者 Guest OS 根本无法处理（因为它看到的是虚拟硬件）。因此，KVM 必须配置 CPU 硬件，在这些异常发生时强制陷入（Trap）到 Hypervisor（EL 2）。

* 1. 内存访问越界或权限错误 (Stage 2 Faults)
    * 场景: 正如我们之前详细讨论的，Guest OS 试图访问一个 KVM 没有分配给它的物理内存地址（IPA），或者对一个只读页面进行写入。
    * 处理: 必须由 KVM 捕获。这是保证虚拟机之间内存隔离的基石。

* 2. 模拟设备 I/O (MMIO - Memory-Mapped I/O)
    * 场景: Guest OS 的驱动程序想要操作一个虚拟网卡，于是向这个虚拟网卡的“设备寄存器地址”写入一个值。这个地址在 Guest 的“物理”地址空间（IPA）里是存在的，但 KVM 故意没有在 Stage 2 页表中为它建立映射。
    * 处理: 必须由 KVM 捕获。这会故意触发一次 Stage 2 Fault。KVM 捕获后，分析出这是一次对虚拟设备的访问，然后通知 QEMU 去模拟对应的硬件行为。这是实现 I/O 虚拟化的核心手段。

* 3. 访问受控的物理系统寄存器
    * 场景: Guest OS 试图直接修改物理 CPU 的中断控制器（GIC）、时钟或电源管理相关的系统寄存器。
    * 处理: 必须由 KVM 捕获。如果允许 Guest 直接操作这些寄存器，它就能关闭其他虚拟机的中断，甚至关闭整个物理机。KVM 会拦截这些访问，可以模拟一个良性的返回结果给 Guest，或者注入一个错误。

* 4. 执行某些特定的敏感指令
    * 场景: Guest OS 因为无事可做，执行了 `WFI` (Wait For Interrupt) 指令，试图让 CPU 进入低功耗休眠状态。
    * 处理: 通常由 KVM 捕获。如果任由 Guest 执行，物理 CPU 就会真的休眠，导致 Host 和其他 VM 都无法运行。KVM 捕获这个指令后，并不会让物理 CPU 休眠，而是将这个 vCPU 标记为空闲状态，然后将物理 CPU 调度给其他需要运行的 vCPU 或 Host 进程，从而提高整体的资源利用率。

### 总结

| 异常类型 | Guest OS 内部处理？ | KVM 捕获处理？ | 核心原因 |
| :--- | :--- | :--- | :--- |
| 系统调用 (`SVC`) | 是 | 否 | 纯属 Guest 内部的用户态到内核态切换，不涉及物理资源。 |
| 普通页错误 (Stage 1 Fault) | 是 | 否 | Guest 管理自己的虚拟内存（换页、写时复制），KVM 不干涉。 |
| 除零、非法指令 | 是 | 否 | 应用层或内核逻辑错误，由 Guest 自行处理（如杀死进程）。 |
| 内存访问越界 (Stage 2 Fault) | 否 | 是 (必须) | 安全隔离：防止 Guest 访问不属于它的物理内存。 |
| 访问模拟设备 (MMIO) | 否 | 是 (必须) | 功能模拟：这是将 Guest 的 I/O 请求传递给 QEMU 进行模拟的机制。 |
| 访问物理系统寄存器 | 否 | 是 (必须) | 资源控制：防止 Guest 直接控制物理硬件（如中断控制器、时钟）。 |

所以，KVM 是一个“聪明的管理者”，它只在必要的时候（威胁到安全、需要提供虚拟服务时）才会介入，其他时候则完全放手让 Guest OS 在自己的沙箱里自由运行。

![image.png](https://raw.githubusercontent.com/ScuDays/MyImg/master/20251001152115.png)
